<!-- FILE: ARCHITECTURE.md -->
<!-- LAST UPDATED: 2026-01-26 -->
<!-- GENERATED BY: WAF KILLER Documentation Generator -->

# üèóÔ∏è WAF KILLER Architecture

## Table of Contents
1. [System Overview](#system-overview)
2. [Core Components](#core-components)
3. [Data Flow](#data-flow)
4. [Detection Pipeline](#detection-pipeline)
5. [Performance Optimizations](#performance-optimizations)
6. [Security Model](#security-model)
7. [Deployment Architectures](#deployment-architectures)
8. [Scalability](#scalability)
9. [API & Integration](#api--integration)

---

## System Overview

WAF KILLER is built on a modular, multi-layered architecture designed to maximize security without compromising performance. It follows these core design principles:

- **Security First**: Every layer is designed with defense-in-depth, from kernel filtering to sandboxed WASM plugins.
- **Extreme Performance**: Low-level optimizations (Rust, eBPF, SIMD) ensure minimal latency.
- **Developer-Centric**: Policy-as-Code and gRPC-based management for modern DevOps workflows.
- **Intelligence at the Edge**: ML classification happens locally on the data plane, reducing dependency on external APIs.

---

## Core Components

### üü¢ Proxy Engine (Axum + Hyper)
The heart of the data plane. It handles TLS termination, HTTP decoding, and connection pooling. Built on the asynchronous foundations of Tokio, it provides non-blocking I/O for massive concurrency.

### üõ°Ô∏è CRS Engine (Coraza)
A Rust-native implementation of the ModSecurity Core Rule Set. It performs deep packet inspection (DPI) against thousands of known attack patterns (SQLi, XSS, LFI) with industry-standard accuracy.

### üß† ML Classifier (ONNX Runtime)
Provides behavioral analysis of incoming requests. By loading pre-trained ONNX models, WAF KILLER can detect anomalous traffic patterns that bypass static rules, identifying zero-day exploits in real-time.

### üå©Ô∏è Threat Intelligence (Redis Cache)
A high-speed lookup system for IP reputation. It aggregates data from global threat feeds (AbuseIPDB, AlienVault) and caches results in a local Redis cluster for <1ms checks.

### ‚è±Ô∏è Rate Limiter (Token Bucket)
Implements sophisticated rate limiting using the Token Bucket and Sliding Window algorithms, preventing brute-force and DDoS attacks at the application layer.

### üéõÔ∏è eBPF Filter (XDP/TC-BPF)
The first line of defense. eBPF programs attached to the network interface (XDP) or traffic control (TC) can drop malicious packets directly in the kernel, bypassing the entire user-space stack for maximum efficiency.

### üß© WASM Plugin System (Wasmtime)
Allows users to extend WAF KILLER with custom detection logic. Plugins are executed in a secure, isolated WebAssembly sandbox, ensuring that custom code cannot crash the core engine.

---

## Data Flow

```ascii
[ INTERNET ]
     |
     v
[ eBPF / XDP Filter ] ---- (Drop Malicious Packets)
     |
     v
[ Proxy Engine (Axum) ] <--- [ TLS Termination ]
     |
     v
[ Detection Pipeline ] <--- (Serial or Parallel execution)
     |
     +--- [ Rate Limiter ]
     |
     +--- [ Threat Intel Lookup ]
     |
     +--- [ CRS Engine (Coraza) ]
     |
     +--- [ ML Classifier ]
     |
     +--- [ WASM Plugins ]
     |
     v
[ Decision Logic ] ---- (Deny / Allow / Challenge)
     |
     v
[ App Backend ]
```

---

## Detection Pipeline

1. **Layer 3/4**: eBPF filters drop IPs based on blocklists or protocol anomalies.
2. **Layer 7 Pre-Processing**: Token validation, GeoIP lookup, and Rate Limiting.
3. **Static Analysis**: Coraza executes CRS rules against headers, cookies, and body.
4. **Behavioral Analysis**: The ONNX model scores the request for "anomalousness".
5. **Enrichment**: The request is compared against real-time Threat Intel feeds.
6. **Decision**: Scores are aggregated; if the threshold is exceeded, the configured action (BLOCK/LOG/CAPTCHA) is taken.

---

## Performance Optimizations

- **Zero-Copy Architecture**: Buffers are passed through the pipeline with minimal cloning.
- **SIMD String Matching**: Uses CPU vector instructions for lightning-fast rule matching.
- **Lock-Free Data Structures**: Minimizes thread contention in the high-concurrency proxy engine.
- **Intelligent Caching**: Multi-level caching (L1 In-Memory, L2 Redis) for threat intel and session data.

---

## Security Model

- **Sandboxing**: Custom logic runs in WASM, isolated from host memory.
- **Least Privilege**: The WAF process runs as a non-root user; eBPF components are loaded once by a privileged launcher and then isolated.
- **Traffic Isolation**: Multi-tenancy support ensures that policies for one domain do not interfere with others.

---

## Deployment Architectures

- **Standalone**: Single binary deployment for simple web servers.
- **Kubernetes Sidebar**: Injected as a sidecar container in K8s pods.
- **Edge Gateway**: Deployed as a centralized entrance for all microservices.

---

## Scalability

WAF KILLER scales horizontally across multiple nodes. State management for rate limiting and threat intel is shared via a **Redis Cluster**, ensuring consistent policy enforcement across the entire fleet.

---

## API & Integration

- **Management API**: gRPC-based API for low-latency configuration updates.
- **Observability**: Prometheus metrics, OpenTelemetry tracing, and structured logs (Loki/JSON).
- **Control Plane**: Full integration with the WAF KILLER Dashboard via WebSockets.
