# Episode 19: eBPF Kernel-Level Filtering

## Overview
This episode introduces eBPF (extended Berkeley Packet Filter) integration, moving the first line of defense from user-space into the Linux kernel (XDP - eXpress Data Path).

## Components

### 1. eBPF Programs (C)
- `ebpf/src/xdp_filter.bpf.c`: The core packet filter.
  - Runs at the NIC driver level.
  - Performs 0-copy filtering.
  - Implements:
    - **Global Blocklist**: Up to 10M IPs (Hash Map).
    - **Rate Limiting**: High-performance packet counting.
    - **Statistics**: Per-CPU counters for observability.

### 2. Rust Integration (Aya)
- Uses `aya` library for loading and managing eBPF programs.
- `core/src/ebpf/manager.rs`: High-level manager to attach programs and modify maps.
- **Global Singleton**: `EBPF_MANAGER` allows API to interact with the kernel maps dynamically.

### 3. API & Dashboard
- New endpoints in `/api/ebpf/*` to check status and sync blocklists.
- Dashboard visualizes the sheer speed and volume of kernel-level filtering.

## Performance
- **Latency**: <100ns drop time.
- **Throughput**: Limited by NIC hardware (can handle 10M+ RPS on standard 10G/25G hardware).
- **CPU Usage**: Almost negligible for blocked traffic compared to user-space handling.

## Usage
1. Compile eBPF programs:
   ```bash
   cd ebpf && make
   ```
2. Run WAF with eBPF enabled:
   ```bash
   export ENABLE_EBPF=true
   export NETWORK_INTERFACE=eth0
   sudo ./waf-killer
   ```

## Requirements
- Linux Kernel 5.10+
- Root privileges
- `libbpf` and `clang` for compilation.
