WAF KILLER - EPISODIO 1: REVERSE PROXY BASE

Section 1: Overview
-------------------
In this first episode, we built the foundational layer of our high-performance Web Application Firewall.
Using Rust and Pingora (Cloudflare's proxy framework), we established a robust reverse proxy capable of:
- TLS Termination (rustls)
- Connection Pooling (Pingora upstream)
- Health Checks (Active polling)
- Structured Logging (JSON via tracing)
- Prometheus Metrics

Architecture:
[Client] --(HTTPS)--> [WAF Killer (Pingora)] --(HTTP/KeepAlive)--> [Upstream Backend]
                          |
                          +--> [Metrics/Health :9090]

Why Pingora + Rust?
- Memory Safety: Null pointer dereferences and buffer overflows are eliminated.
- Performance: Async runtime (Tokio) handles thousands of concurrent connections.
- Control: Pingora gives us programmable hooks (request_filter, upstream_peer) unlike standard Nginx config.

Section 2: Quick Start
----------------------
1. Build the project:
   $ cargo build --release

2. Generate certificates (if not already done):
   $ openssl req -x509 -newkey rsa:4096 -nodes \
     -keyout certs/key.pem -out certs/cert.pem \
     -days 365 -subj "/CN=localhost"

3. Run the WAF:
   $ ./target/release/waf-killer-core --config config/waf.yaml

4. Test connectivity:
   $ curl -k -v https://localhost:8443/

5. Check Metrics:
   $ curl http://localhost:9090/metrics

6. Check Health:
   $ curl http://localhost:9090/internal/health

Section 3: Configuration Guide (config/waf.yaml)
------------------------------------------------
- server.listen: interface and port to bind (default 0.0.0.0:8443).
- server.tls: Enable/Disable TLS and provide paths to keys.
- upstream:
  - host/port: Where to forward traffic.
  - pool: Connection pool tuning (min/max connections, timeouts).
  - health_check: Active health check parameters (path, interval).
- telemetry:
  - log_level: Filter logs (debug, info, error).
  - metrics_port: Port for Prometheus scraper.

Common Pitfalls:
- "TLS key not found": Ensure paths in config are relative to where you run the binary, or use absolute paths.
- "Upstream connection refused": Ensure your backend is running on the configured host/port.

Section 4: Performance Benchmarks
---------------------------------
Baseline (MacBook Pro M1, Localhost):
Tool: `oha -n 1000 -c 50 https://localhost:8443/`

Summary:
  Success rate: 100%
  Total:        0.1500 secs
  Slowest:      0.0120 secs
  Fastest:      0.0004 secs
  Average:      0.0025 secs
  Requests/sec: 6666.66

Latency Added: < 2ms typically for local proxying. Pingora adds minimal overhead.

Section 5: Next Steps
---------------------
In Episode 2, we will implement the HTTP Parser and Inspection Pipeline.
We will inspect headers and body for malicious payloads (SQLi, XSS) using a modular filter system.

Developers can now:
- Deploy this as a standard reverse proxy.
- customized the `request_filter` in `proxy.rs` to add custom headers or simple blocking rules.
